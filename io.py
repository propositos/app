# -*- coding: utf-8 -*-
"""io.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b-TD_uvUFOBIucGloK_oLppecANI2GDO
"""

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
import os
import dask.dataframe as dd
import dask.array as da
from google.colab import drive
from sklearn.utils import resample

# Autenticação e montagem do Google Drive
drive.mount('/content/drive')

# Diretório no Google Drive onde os arquivos serão salvos
DRIVE_PATH = '/content/drive/MyDrive/graficos'
SUMMARY_PATH = '/content/drive/MyDrive/sumarios'

# URL do dataset
SPREADSHEET_URL = "https://docs.google.com/spreadsheets/d/10dcM6isHjL7g-Ls0UaK1jiHwNzlaGJneYWH-Z4rAKnA/export?format=csv&gid=1484787974"

# Configurações gerais de gráficos
FIGSIZE = (10, 6)
PALETTE = 'coolwarm'
BACKGROUND_COLOR = 'black'
TEXT_COLOR = 'white'
BOOTSTRAP_SAMPLES = 1000

# Função para salvar gráficos em alta qualidade no Google Drive
def save_fig(filename, graphpath):
    filepath = os.path.join(graphpath, filename)
    plt.savefig(filepath, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"Gráfico salvo em {filepath}")

# Função para realizar o bootstrap e retornar um DataFrame com os dados amostrados
def bootstrap_data(df, n_iterations=BOOTSTRAP_SAMPLES):
    bootstrapped_dfs = []
    for i in range(n_iterations):
        bootstrapped_df = resample(df.compute(), replace=True)
        bootstrapped_dfs.append(bootstrapped_df)
    bootstrapped_df = pd.concat(bootstrapped_dfs)
    return dd.from_pandas(bootstrapped_df, npartitions=4)

# Classe para gerar gráficos, incluindo regressões polinomiais
class GraphGenerator:
    def __init__(self, df, graphpath):
        self.df = df
        self.graphpath = graphpath

    def _adjust_palette(self, hue):
        if hue:
            unique_vals = self.df[hue].nunique().compute()
            return sns.color_palette(PALETTE, n_colors=unique_vals)
        return None

    def _style_plot(self):
        plt.gca().set_facecolor(BACKGROUND_COLOR)
        plt.title(plt.gca().get_title(), color=TEXT_COLOR)
        for spine in plt.gca().spines.values():
            spine.set_color(TEXT_COLOR)
        plt.gca().tick_params(axis='both', colors=TEXT_COLOR)
        plt.gca().yaxis.label.set_color(TEXT_COLOR)
        plt.gca().xaxis.label.set_color(TEXT_COLOR)

    def generate_scatterplot(self, x, y, hue, title, filename):
        plt.figure(figsize=FIGSIZE, facecolor=BACKGROUND_COLOR)
        sns.scatterplot(
            x=self.df[x].compute(),
            y=self.df[y].compute(),
            hue=self.df[hue].compute() if hue else None,
            palette=self._adjust_palette(hue),
            s=100
        )
        plt.title(title, color=TEXT_COLOR)
        self._style_plot()
        save_fig(filename, self.graphpath)

    def generate_violinplot(self, x, y, hue, title, filename):
        plt.figure(figsize=FIGSIZE, facecolor=BACKGROUND_COLOR)
        sns.violinplot(
            x=x, y=y, hue=hue,
            data=self.df.compute(),
            split=True,
            palette=self._adjust_palette(hue)
        )
        plt.title(title, color=TEXT_COLOR)
        self._style_plot()
        save_fig(filename, self.graphpath)

    def generate_kdeplot(self, x, y, hue, title, filename):
        plt.figure(figsize=FIGSIZE, facecolor=BACKGROUND_COLOR)
        sns.kdeplot(
            x=self.df[x].compute(),
            y=self.df[y].compute(),
            hue=self.df[hue].compute() if hue else None,
            palette=self._adjust_palette(hue),
            fill=True
        )
        plt.title(title, color=TEXT_COLOR)
        self._style_plot()
        save_fig(filename, self.graphpath)

    def generate_boxplot(self, x, y, hue, title, filename):
        plt.figure(figsize=FIGSIZE, facecolor=BACKGROUND_COLOR)
        sns.boxplot(
            x=x, y=y, hue=hue,
            data=self.df.compute(),
            palette=self._adjust_palette(hue)
        )
        plt.title(title, color=TEXT_COLOR)
        self._style_plot()
        save_fig(filename, self.graphpath)

    def generate_regression_plot(self, x, y, degree, title, filename):
        plt.figure(figsize=FIGSIZE, facecolor=BACKGROUND_COLOR)
        try:
            x_data = self.df[x].compute()
            y_data = self.df[y].compute()

            coefficients = np.polyfit(x_data, y_data, degree)
            polynomial = np.poly1d(coefficients)
            x_fit = np.linspace(min(x_data), max(x_data), 100)
            y_fit = polynomial(x_fit)

            sns.scatterplot(x=x_data, y=y_data, color='cyan', s=100)
            plt.plot(x_fit, y_fit, 'r-', label=f'Regressão Polinomial (grau {degree})')
            plt.title(title, color=TEXT_COLOR)
            self._style_plot()
            plt.legend(labelcolor=TEXT_COLOR)
            save_fig(filename, self.graphpath)
        except Exception as e:
            print(f"Erro ao gerar gráfico de regressão polinomial: {e}")

# Funções auxiliares
def create_folders():
    os.makedirs(DRIVE_PATH, exist_ok=True)
    os.makedirs(SUMMARY_PATH, exist_ok=True)
    return DRIVE_PATH, SUMMARY_PATH

def load_data(url):
    try:
        df = dd.read_csv(url)
        return df
    except Exception as e:
        print(f"Erro ao carregar os dados: {e}")
        return None

def generate_statistical_summary(df, summarypath):
    try:
        summary = df.describe().compute().T
        summary_file = os.path.join(summarypath, 'summary.csv')
        summary.to_csv(summary_file)
        print(f"Sumário estatístico salvo em {summary_file}")
    except Exception as e:
        print(f"Erro ao gerar sumário estatístico: {e}")

# Função principal
def main():
    graphpath, summarypath = create_folders()
    df = load_data(SPREADSHEET_URL)

    if df is not None:
        # Realiza o bootstrap nos dados
        bootstrapped_df = bootstrap_data(df)

        # Gera o sumário estatístico
        generate_statistical_summary(bootstrapped_df, summarypath)

        # Inicializa o gerador de gráficos com os dados amostrados
        graph_gen = GraphGenerator(bootstrapped_df, graphpath)

        # Gráficos de regressão polinomial
        regression_plots = [
            ('pre_score', 'post_score', 3, 'Pre vs Post Score'),
            ('focused_total', 'post_score', 3, 'Focused Total vs Post Score'),
            ('seconds_Attention_Output', 'post_score', 3, 'Seconds Attention vs Post Score'),
            ('over_40', 'post_score', 3, 'Over 40 vs Post Score'),
            ('over_40_del1', 'post_score', 3, 'Over 40 Del1 vs Post Score'),
            ('focused_total', 'seconds_Attention_Output', 3, 'Focused Total vs Seconds Attention')
        ]

        for x_col, y_col, degree, title_prefix in regression_plots:
            graph_gen.generate_regression_plot(
                x=x_col, y=y_col, degree=degree,
                title=f'Regressão Polinomial (grau {degree}): {title_prefix}',
                filename=f'regression_polynomial_{x_col}_{y_col}.png'
            )

        # Gráficos kde
        kde_plots = [
            ('pre_score', 'post_score', 'type', 'Distribuição KDE Pre vs Post Score'),
            ('focused_total', 'post_score', 'type', 'Distribuição KDE Focused Total vs Post Score')
        ]

        for x_col, y_col, hue, title_prefix in kde_plots:
            graph_gen.generate_kdeplot(
                x=x_col, y=y_col, hue=hue,
                title=title_prefix,
                filename=f'kde_{x_col}_{y_col}.png'
            )

        # Gráficos de violino bipartido
        violin_plots = [
            ('type', 'pre_score', 'type', 'Distribuição de Pre Score por Tipo'),
            ('type', 'post_score', 'type', 'Distribuição de Post Score por Tipo'),
        ]

        for x_col, y_col, hue, title_prefix in violin_plots:
            graph_gen.generate_violinplot(
                x=x_col, y=y_col, hue=hue,
                title=title_prefix,
                filename=f'violin_{x_col}_{y_col}.png'
            )

if __name__ == "__main__":
    main()